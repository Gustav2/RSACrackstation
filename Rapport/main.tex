\documentclass[a4paper,12pt]{extarticle}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[danish]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{anyfontsize}

\usepackage{minted}

\usepackage[parfill]{parskip}

\usepackage{wrapfig}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amstex}

\begin{document}
    \begin{titlepage}
        \begin{center}
            \vspace{1cm}

            \textbf{RSACrackstation}

            \vspace{0.5cm}
            Rapport over RSACrackstation projektet

            \vspace{1.5cm}

            \textbf{Daniel Nettelfield og Gustav Nybro}

            \vfill

            A thesis presented for the degree of\\
            Doctor of Philosophy

            \vspace{0.8cm}

            Teknisk Gymnasium Silkeborg\\
            3x\\
            31/10 - 2022

        \end{center}
    \end{titlepage}

    \newpage

    \tableofcontents

    \section{Abstract}\label{sec:abstract}

    Your introduction goes here! Simply start writing your document and use the Recompile button to view the
    updated PDF preview. Examples of commonly used commands and features are listed below, to help you get started.

    Once you're familiar with the editor, you can find various project settings in the Overleaf menu, accessed
    via the button in the very top left of the editor. To view tutorials, user guides, and further documentation,
    please visit our \href{https://www.overleaf.com/learn}{help library}, or head to our plans page to
    \href{https://www.overleaf.com/user/subscription/plans}{choose your plan}.


    \section{Problemformulering}\label{sec:problemformulering}

    \subsection{Beskrivelse}\label{subsec:beskrivelse}
    Hjemmesiden er en side der kan faktorisere primtal ved hjælp at af API call til en ekstern database.
    Derudover kan hjemmesiden bruges til at bryde krypteringsalgoritmen RSA, og dertil dekryptere indtastet tekst.
    Derudover kan hjemmesiden også bruges til at kryptere tekst med RSA. Hjemmesidens målgruppe er primært CTF
    spillere, cybersikkerheds entusiaster og andre der skal kryptere og dekryptere med RSA\@.

    \subsection{Krav}\label{subsec:krav}
    \begin{itemize}
        \item Hjemmesiden skal kunne faktorisere primtal.
        \item Hjemmesiden skal kunne bryde RSA kryptering.
        \item Hjemmesiden skal kunne kryptere med RSA\@.
    \end{itemize}



    \section{Hvad er RSA?}\label{sec:hvad-er-rsa}
    RSA er en asymmetrisk kryptografialgoritme, som er udviklet af Ron Rivest, Adi Shamir og Leonard Adleman i 1977.
    En asymmetrisk kryptografialgoritme er en kryptografialgoritme der bruger to forskellige nøgler til at kryptere og dekryptere,
    og bruges ofte af blandt andet banker, til at sikre deres data.
    Idéen er er man kan offenliggøre krypteringsnøglen, men beholde dekrypteringsnøglen privat, så brugere kan kryptere data på deres egen maskine,
    og sende den krypterede tekst til banken, som dekrypterer den med sin private nøgle.
    RSA nøglerne er genereret ved at bruge to primtal, som er valgt tilfældigt.
    Den offentlige nøgle regnes ved at gange de to primtal sammen, og den private ved at bruge en kompliceret algoritme,
    der hedder den Udvidede Euklidske Algoritme.\@
    De to tilfældige primtal kaldes \emph{p} og \emph{q}, deres produkt (den offentlige nøgle) kaldes \emph{n}, og den private nøgle kaldes \emph{d}.
    Udover at bruge primtal til at generere RSA nøglerne, bruger RSA også en eksponent, som har en række af krav den skal opfylde,
    alt efter værdierne af de to primtal.
    Dog findes der et tal, som altid kan bruges som eksponent, og det er 65537, denne eksponent kaldes \emph{e}.
    Det sidste tal man bruger i RSA, hedder \emph{m}, og er den værdi man gerne vil sende, ofte en tekst.\@

    \subsection{Hvordan virker RSA?}\label{subsec:hvordan-virker-rsa}
    Når man krypterer med RSA, bruges følgende formel:
    
    \begin{equation}
        c = m^e \mod n \label{eq:rsa-encrypt}
    \end{equation}
    
    Her bruges modulus regning, som er måden man sikrer, at den krypterede tekst, ikke kan dekrypteres.
    Modulus virker nemlig ved at tage resten efter en heltalsdivision,
    det vil sige at flere udregninger godt kan give det samme resultat
    
    \begin{equation}
        2^{11} \mod 527 = 467 \label{eq:encrypt-ex1}
    \end{equation}
    \begin{equation}
        106^{13} \mod 551 = 467 \label{eq:encrypt-ex2}
    \end{equation}
    
    I dette eksempel, er \(\textbf{m} = 2\), i ligning~\eqref{eq:encrypt-ex1} og \(\textbf{m} = 106\) i ligning~\eqref{eq:encrypt-ex2}.
    så man kan man se at bare fordi man kender \textbf{c} betyder det ikke at man kender \textbf{m},
    da \textbf{c} er ens i begge eksempler, men \textbf{m} er forskellige.
    For at dekryptere denne tekst skal man bruge værdien for \textbf{d}, som findes ved at faktorisere de to \textbf{n}`er.
    I dette eksempel bruger vi meget små tal, og det er derfor meget nemt at faktorisere de to moduluer.
    Når man har faktoriseret \textbf{n}, kan man køre den udvidede Euklidske algoritme, som bruges til at finde \textbf{d}.
    Hvis man kører denne algoritme på vores to eksempler, får man \(\textbf{d} = 131\) og \(\textbf{d} = 349\).\@
    \textbf{D} kaldes for den inverse af \(\textbf{e} \mod \textbf{n}\), og bruges til at gøre det modsatte af kryptering.
    Når man har regnet \texbf{D}, er det meget enkelt at dekryptere, man skal nemlig gøre det samme som når man kryptere,
    men med \textbf{d} i stedet for \textbf{e}:
    
    \begin{equation}
        m = c^d \mod n \label{eq:rsa-decrypt}
    \end{equation}
    
    Hvis man gør dette for vores to eksempler får man dette:
    
    \begin{equation}
        467^{131} \mod 527 = 2 \label{eq:decrypt-ex1}
    \end{equation}
    \begin{equation}
        467^{349} \mod 551 = 106 \label{eq:decrypt-ex2}
    \end{equation}
    
    Hvor de to resultater, er de samme to tal, vi krypterede til at starte med, og vi har altså dekrypteret vores tekst.

    \section{Hvad er en API?}\label{sec:hvad-er-en-api}
    API står for Application programming interface, hvilket er en måde for noget kode at intergere med noget andet kode.
    En API er modsætningen til en bruger interface, som er et interface ment til mennesker.
    API calls kan enten ændre data eller hente data fra en server.
    APIs er overalt på internettet og største delen af populære hjemmesider bruger APIs.
    Et godt eksempel på en API der bliver brugt af mange mennesker, er Rejseplanen.
    Rejsplanen fungerer ved at en bruger indtaster noget data, som bliver sendt til backenden.
    Backenden sender kun rå JSON data tilbage, som frontenden behandler og viser på en måde, brugeren lettere kan forestå.


    \section{Frontend}\label{sec:frontend}
    \subsection{Intro}
    For at kunne bruge hjemmesiden ordenligt er et vigtigt med et brugervenligt interface.
    For at kunne lave et brugervenligt interface, skal der bruges HTML, CSS og JavaScript.
    Det er muligt at lave en flot og meget brugervenligt interface med blot normal CSS og JavaScript,
    men for hurtigere at kunne udvikle vores produkt, valgte vi at bruge Tailwind CSS og JQuery i stedet.
    Tailwind CSS er et CSS framework, der han en masse prædefineret klasser, som kun har en bestemt funktion.
    Man kan derfor hurtigt lave et flot interface, uden at skulle skrive CSS selv, men bare bruge de prædefinerede klasser.
    Tailwind gør det også nemmere at lave et responsivt UI, da hele frameworket er bygget op omkring det.


    \subsection{Tailwind CDN}
    For at kunne bruge Tailwind frameworket, har man flere forskellige muligheder, dog er der to oplagte:
    \begin{enumerate}
        \item Installere Tailwind via NPM
        \item Loade Tailwind med en CDN (Content Delivery Network)
    \end{enumerate}
    Eftersom vi ikke ville gøre det her projekt mere avanceret end nødvendig, og fordi projektet ikke skal hostes i et produktionsmiljø, kan vi godt nøjes med CDN versionen.
    Hvis hjemmesiden skulle bruges i produktion, ville man ikke bruge Tailwind via CDN, fordi det er ressourcer der skal hentes fra en 3. part, hvilket kan give forskellige problemer.
    Eksempelvis hvis Tailwinds servere går ned, ser alle hjemmesider, der bruger Tailwinds CDN, meget anderledes ud, fordi CSS'en ikke kan loades.
    CDN'en indeholder også alle klasser og skal derfor loade mere end nødvendigt, hvilket kan gøre hjemmesiden lidt langsommere.

    \medskip

    Dette projekt var også småt nok, til at det ville tage en betydelig del af tiden, at sætte Tailwind op ordenligt.
    Tailwind via NPM virker kun, hvis der kører en process og scanner HTML filerne for opdateringer og laver de klasser der mangler.
    Det betyder så også at Tailwind kun indeholder hvad der bliver brugt og intet andet, i modsætning til mange andre CSS frameworks, så som Bootstrap.

    \subsection{Darkmode}
    Alle vores HTML elementer som er blevet ændret med Tailwind, har to forskellige klasser - en til darkmode og en til lightmode.
    Et eksempel kan ses nedenfor

    \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize]{html}
        <div class="w-fit dark:text-white text-gray-800">
        ...
    \end{minted}

    I eksemplet ovenfor bliver der oprette et $<div>$ tag som indeholder nogle elementer.
    Tagget har to klasser der ændrer tekstens farve, som burde overskrive hinanden, men fordi den ene har \emph{dark:} foran,
    bliver den kun brugt når darkmode er slået til.

    \subsection{Hex Auto Toggle}

    Hjemmesiden kan arbejde både med decimaltal og hexadecimaltal, og der er en knap der skifter mellem dem.
    Hvis man kopirer tallet et sted fra, kan man nemt glemme at skifte mellem de to, hvilket er derfor den automatisk
    skifter mellem dem, afhængig af hvad der er indsat i inputfeltet.
    Koden nedenfor skifter automatisk mellem de to.

    \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos]{javascript}
    // Checks if number is pasted and automatically changes state to hex if hex is pasted
    $("#num").bind('paste', function(e) {
        let data = e.originalEvent.clipboardData.getData('text'); // Gets data from clipboard
        if (/[A-Za-z]/g.test(data)) {  // Regex to check if hex is pasted
            if (!isHex){
                updateHexToggle();
            }
        }
        else if (isHex){
            updateHexToggle()
        }
    });
    \end{minted}

    \medskip

    I linje 2 refererer vi til elementet \emph{num}, som er tekstfeltet, hvor man kan indtaste sit tal.
    Efter det tjekker vi om der bliver 'pasted' tal ind i inputfeltet og laver en funktion som kører hvis det bliver.

    \medskip

    I linje 3 initialisere vi en variabel i local scope, der indeholder dataen i upklipsholderen, som læses direkte fra udklipsholderen i stedet for tekstfeltet.
    Dette gør vi for at undgå fejl.

    \medskip

    I linje 4-8 tjekker vi om dataen fra variablen i linje 3, indeholder store eller små bogstaver og kører funktionen \emph{updateHexToggle()} hvis variablen \emph{isHex} er falsk.
    Vi kører funktionen for at opdatere knappen man kan se på hjemmesiden, samt variablen \emph{isHex}.
    If-statementet tjekker om der er bogstaver i teksten, da hexadecimale tal ofte er en blanding mellem bogstaver og tal.
    Dette er ikke en helt sikker måde at skifte mellem tallene, fordi mindre tal nogle gange ikke indeholder bogstaver.
    Det er dog umuligt at tjekke om et tal er hex eller ej, uden at bruge den her metode. Eksempelvis kan tallet 33 forståes som både hex og decimal.

    \medskip

    Hvis tallet ikke indeholder bogstaver kører koden mellem linje 9 og 12.
    Denne kode tjekker igen om variablen \emph{isHex} er sand, og kører funktionen \emph{updateHexToggle()}.
    Det tjekker blot om knappe allerede er sat til hex og skifter den tilbage til decimal, hvis teksten der bliver indsat er decimal.


    \section{Backend}\label{sec:backend}
    Backenden er den del af hjemmesiden, som ikke bliver vist til brugeren.
    Det er her vi behandler dataen, som bliver sendt til os fra frontend.
    Vores backend er skrevet i C\#, og bruge objektorienteret programmering, hvor vi laver klasser til at håndtere forskellige ting.
    
    \subsection{Primtalsfaktorisering}\label{subsec:prime-factorization}
    For at bryde RSA-algoritmen, skal man faktorisere det store tal \textbf{n}, som er produktet af to primtal.
    At faktorisere store tal er en meget svær opgave, som kræver meget tid og ressourcer.
    Det er derfor ikke muligt at faktorisere tallet, når brugeren anmoder om det.
    For at løse dette, findes der store databaser af tal, som er faktoriserede.
    Når en bruger indtaster et tal på hjemmesiden, sender vi talet videre til en database, der hedder factordb.
    Factordb er den største database af faktoriserede tal, og den er gratis at bruge.
    Hvis talet findes i databasen, sender vi det tilbage til brugeren, og hvis det ikke findes, sender vi en fejlmeddelelse.
    Vores implementation af dette kan ses nedenfor.
    \begin{listing}[!ht]
    \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos]{csharp}
public string[] GetFactors(){
    string[] factors = { "-1", "-1" };
    var url = $"http://factordb.com/api?query={_n}";
    var request = WebRequest.Create(url);
    request.Method = "GET";
    var data = "";
    ...
    
    dynamic jsonData = JsonObject.Parse(data);
    ...

    for (var i = 0; i < 2; i++){
        factors[i] = jsonData["factors"][i][0].ToString();
    }
    
    return factors;
}
    \end{minted}
    \caption{/Backend/RSACracker.cs, Linje 42}
    \end{listing}
    
    På linje 1 defineres en metode, der hedder \emph{GetFactors()}, som returnere et array af strings.
    Et array er en datastruktur der kan indeholde flere værdier af samme type.
    I dette tilfælde indeholder arrayet to strings, som er de to faktorer der kommer af at faktorisere \textbf{n}.
    På linje 2 initialiseres arrayet med to strings, som er sat til -1.
    \{-1, -1\} er vores default værdi, som vi bruger til at checke om vi har fået en faktorisering fra factordb.
    På linje 3 defineres en variabel, der hedder \emph{url}, som er en streng af tekst, der indeholder den url vi skal sende vores API forespørgsel til.
    På linje 4 defineres en variabel, der hedder \emph{request}, som er af typen \emph{WebRequest}.
    WebRequest er en klasse, der indeholder metoder til at sende forespørgsler til en server.
    I dette tilfælde, bruger vi typen af forespørgslen, der hedder `GET`, som er den mest almindelige type af forespørgsler.
    Med en `GET` forespørgsel, kan vi hente data fra en server, uden at ændre noget på den, 
    hvilket er det vi ønsker i dette tilfælde.
    På linje 5 definere vi en ny variabel, af typen string, som hedder \emph{data}.
    Der er her vores respons fra factorDB, skal ligge.
    Derefter kommer der en masse kode, som ikke er vigtig for at forstå hvordan vi bruger API'en.
    På linje 11 definere vi endnu en variabel, der hedder \emph{jsonData}, som er af typen \emph{JsonObject}, 
    hvilket lader os håndtere JSON data, som vi får fra factorDB.\@
    Derefter kommer der lidt kode, som undersøger om vi får en gyldig respons, dette er ikke nødvendigt at gennegå.
    
    \subsection{RSA Funktionalitet}\label{subsec:rsa-functionality}
    \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos]{csharp}
    \end{minted}

    \subsection{API call}\label{subsec:api-call}

    \section{Konklusion}\label{sec:konklusion}

\end{document}
